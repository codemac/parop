#!/bin/sh
# -*- scheme -*-
exec guile -e "main" -s "$0" "$@"
!#
;;;;
;;;;
;;; raw text/template can include ~(). Scheme/script can include #~. they
;;; should be able to nest. Next is to figure out how to wrap this all
;;; up in sxml.
;;;
;; ok, so there is ~(), which we can do inline anywhere, and then
;; replace with

(use-modules (ice-9 format)
	     (ice-9 q)
	     (srfi srfi-2)
	     (sxml simple)
	     (sxml xpath))

(define (usage)
  (display "parop -<attr>:<value> inputscript.pop > outputfile"))

;; can replace the q-empty? check once this is working more properly,
;; so the exception can unwind entirely up the stack, alerting us when
;; we're doing some amount of xml propagation that we didn't want to
;; do.
(define (scope-current)
  (if (q-empty? *scope-q*)
      #f
      (q-front *scope-q*)))

(define *scope-q* (make-q))


(define* (ref sym #:optional (case 'none))
  ;; look up symbol in xml-ness
  ;; first look at current sxml scope
  (scope-current)
  )

;; find list of relevant things, finding the most specific possible
;; reference, whether they be attributes or what.

(define (scope-push syms)
  "For each in SYM, push scope until we find what we're looking for,
or error that we didn't find what was specified."
  (push-q! ((sxpath syms) (scope-current)) *scope-q*))

(define* (for-ref syms proc #:optional (case 'none))
  "For each element in the list of SYM, do the following proc. SYM is
split by dots, no dotted symbols are allowed because I say so."
  (let* ((split-syms (map string->symbol (string-split (symbol->string syms) #\.)))
	 (scope      (sxml-ref syms (scope-current))))
    (for-each proc scope)))

(define (printable-to-chars p)
  (reverse
   (string->list
    (format #f "~a" p))))

(define (process-inner-raw-loop iport)
  (define rawresult '())
  (let loop ((cic (read-char iport)))
    (cond
     ((eof-object? cic)
      (error "Didn't find a concluding ~#, bug??"))
     ((eq? cic #\~)
      (cond
       ((eq? (peek-char iport) #\#)
	(begin
	  ;; advance 1 char to get rid of hash
	  (read-char iport)
	  `(display ,(reverse-list->string rawresult))))
       ((eq? (peek-char iport) #\()
	(and-let* ((expr (read iport))
		   (outr (open-output-string))
		   (oldout (current-output-port))
		   ((set-current-output-port outr))
		   (output (primitive-eval expr))
		   ((set-current-output-port oldout)))
	  (set! rawresult (append (reverse (string->list (get-output-string outr))) rawresult)))
	(loop (read-char iport)))
       ((eq? (peek-char iport) #\~)
	(begin
	  (read-char iport)
	  (set! rawresult (cons cic rawresult))
	  (loop (read-char iport))))
       (else
	(error "Dangling tilde!"))))
     (else
      (begin
	(set! rawresult (cons cic rawresult))
	(loop (read-char iport)))))))

(define (process-inner-raw char iport)
  ;; first, read in first newline
  (cond
   ((eq? (peek-char iport) #\newline)
    (read-char iport)
    (process-inner-raw-loop iport))
   (else
    (error "Need newline after beginning #~!"))))

;; install the handler into the scheme reader
(read-hash-extend #\~ process-inner-raw)

(define (printable? s)
  (or (number? s)
      (string? s)
      (list?   s)
      (symbol? s)))

;; lifted from lips
(define (process-outer-raw iport oport)
  (define line-number 0)
  (define first-character #t)
  ;line-number -> for error reporting
  ;first-character -> are we processing the first character of the line?
  ;			If so and it is a macro that produces no printable output
  ;			and nothing else is on the line
  ;			we will remove the following newline
  ;we're going to loop over all the characters
  ;in the file looking for escapes
  ;cic -> current input character
  (let loop ((cic (read-char iport)))
      (cond 
	;if we find a tilda then check to see if the next character
	;is also a tilda. If it is, then we output a tilda and eat the
	;tilda from input.
	((eq? cic #\~)
		(if (eq? (peek-char iport) #\~)
		  (begin
		    (display "~" oport)
		    (read-char iport))
		  ;if the next character is not a tilda then read in a s-exp
			;evaluate and print output
			;if we're at the beginning of a line and the character
			;following the expression is a newline then, if the expression
			;doesn't evaluate to something printable, ignore the newline
		  (let* ((expr (read iport))
		        (output (primitive-eval expr))) 
		      (if (printable? output)
			(display output oport)
			(if (and first-character
			      (eq? (peek-char iport) #\newline))
			  (read-char iport))))))

	((eq? cic #\newline)					
		(display cic oport)
		(set! first-character #t)
		(set! line-number (1+ line-number)))

	((eof-object? cic))

	(else
	 	(if first-character 
		  (set! first-character #f))
	  	(display cic oport)))

      (if (not (eof-object? cic))
        (loop (read-char iport)))))

(define* (read-and-eval! #:optional (port (current-input-port)))
  (let repl-loop ((expr (read port)))
    (if (not (eof-object? expr))
	(let ((output (primitive-eval expr)))
	  (if (printable? output)
	      (display output))
	  (repl-loop (read port))))))

;; we should define how we want to read. Either in SXML default
;; (i.e. template data), RAWTEXT default (template text), or in SCHEME
;; default (i.e. script).
;;
;; TODO: What is the difference between template data & template
;; rawtext? I think it's potentially that the scheme reader is not
;; like an XML reader. It doesn't just let raw text exist
;; e'erywhere.... shit my template language (empty text) doesn't
;; include sxml parsing! ass! (wait yes it does! ~( raw mode! ).).
(define (main args)
  (case (length args)
    ((2)
     (set-current-input-port (open-file (list-ref args 1) "r")))
    ((1) '())
    (else (usage)))

  ;; if scheme mode (will we ever do this?!)
  (read-and-eval!)

  ;; if 'raw' mode
;  (process-outer-raw (current-input-port) (current-output-port))
  )
